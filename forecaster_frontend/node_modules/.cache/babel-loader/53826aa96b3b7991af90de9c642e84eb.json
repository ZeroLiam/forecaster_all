{"remainingRequest":"/Users/zeroliam/Documents/PROJECTS/AppsFactory task/forecaster_all/forecaster/node_modules/babel-loader/lib/index.js!/Users/zeroliam/Documents/PROJECTS/AppsFactory task/forecaster_all/forecaster/node_modules/vue-loader/lib/index.js??vue-loader-options!/Users/zeroliam/Documents/PROJECTS/AppsFactory task/forecaster_all/forecaster/src/views/Home.vue?vue&type=script&lang=js&","dependencies":[{"path":"/Users/zeroliam/Documents/PROJECTS/AppsFactory task/forecaster_all/forecaster/src/views/Home.vue","mtime":1534957733320},{"path":"/Users/zeroliam/Documents/PROJECTS/AppsFactory task/forecaster_all/forecaster/node_modules/cache-loader/dist/cjs.js","mtime":1534748859164},{"path":"/Users/zeroliam/Documents/PROJECTS/AppsFactory task/forecaster_all/forecaster/node_modules/babel-loader/lib/index.js","mtime":1529635966000},{"path":"/Users/zeroliam/Documents/PROJECTS/AppsFactory task/forecaster_all/forecaster/node_modules/vue-loader/lib/index.js","mtime":499162500000}],"contextDependencies":[],"result":["import \"core-js/modules/es6.array.find\";\nimport \"core-js/modules/es6.regexp.split\";\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n// @ is an alias to /src\nimport Query from \"@/components/Query.vue\";\nimport Results from \"@/components/Results.vue\"; // Import axios for the ajax call (works with Vuejs)\n// Import lodash to loop in the response and pass it to the result array\n\nimport axios from 'axios';\nimport _ from 'lodash';\nexport default {\n  name: \"home\",\n  components: {\n    Query: Query,\n    Results: Results\n  },\n  data: function data() {\n    return {\n      reqCity: \"your city\",\n      //request city (from search query component)\n      allForecast: [],\n      //all the result objects from the server's response \n      ajaxerror: null //in case there's an error in the ajax call, but don't fill this out yet\n\n    };\n  },\n  methods: {\n    onSearchSubmit: function onSearchSubmit(value) {\n      this.reqCity = value; //the value we receive from the Query component via @clicked, to the reqCity variable\n\n      this.getObj(); //After we get the value, then we can make the ajax call\n    },\n    getObj: function getObj() {\n      var _this = this;\n\n      //url from the localhost; grabs forecast from the custom made ASP.Net Core API\n      axios(\"https://localhost:5001/api/weather/forecast?city=\" + this.reqCity, {\n        method: 'GET',\n        // THE FOLLOWING IS TO ALLOW THE LOCALHOST TO ACCESS THE BACKEND\n        // I know this is a bad practice, but this is just for the localhost.\n        // On production this will change, to reinforce credentials\n        mode: 'no-cors',\n        headers: {\n          'Access-Control-Allow-Origin': '*',\n          'Content-Type': 'application/json'\n        }\n      }) // IF THE PROMISE SUCCEEDS...\n      .then(function (response) {\n        //We reset the allForecast variable, to clean it from previous value, enabling re-use\n        _this.allForecast.length = 0; //Let's find what we want: today's weather and forecast for the next 5 days\n        //First, let's find the weather, and also assign an id. The response.data.forecast\n        //comes with 40 items, starting with the weather for today at the last reading (from the \n        //OpenWeatherApp) until the equivalent last hour reading five days from now.\n        //How can we find the five days forecast? Let's check it out:\n        //VARS:\n        // -----------------------------------------------------------------------------------\n        // find: Keeps track of the index on the response.data.forecast. The data is read\n        //       every three hours, so every 8 readings is the data of this same time period,\n        //       but on the following days.\n        // id:   We need to keep track of an id for today and the next days. This id will be\n        //       passed on the result object we're collecting.\n        // -----------------------------------------------------------------------------------\n\n        var find = 0,\n            id = 0; //Let's loop this baby\n\n        for (var key = 0; key < response.data.forecast.length; key++) {\n          //Hey! If the key matches the find, then we got an object for the day!\n          if (key === find) {\n            //Our object will contain id, city, day (as in date mm/dd), temperature, humidity, and wind speed\n            //^^ (based on specs) \n            var obj = {\n              id: id,\n              city: response.data.city,\n              day: response.data.forecast[find].dt_txt.split(\" \")[0],\n              temp: response.data.forecast[find].main.temp,\n              humidity: response.data.forecast[find].main.humidity,\n              windspeed: response.data.forecast[find].wind.speed //Once we capture our object, we push it to the allForecast array :)\n\n            };\n\n            _this.allForecast.push(obj); //Now find will be find + 7, i.e. second match will be key === 7 and find === 7\n\n\n            find += 7; //Remember to update the id! Otherwise the objects will have the same id and that's\n            //not good for our children components! (Do it for the children bro)\n\n            id++;\n          }\n        } //After all the wilderness has passed, also put the ajaxerror as null here.\n        //This avoids to have the ajaxerror displaying when the new query is successful.\n\n\n        _this.ajaxerror = null;\n      }) //IF THE PROMISE IS UNSUCCESSFUL...\n      .catch(function (error) {\n        // Error! you found it? You post it!\n        if (error.response.status == 400) {\n          _this.ajaxerror = \"That zip code or city is not in Germany, or is made up. Please review your input.\";\n        }\n      });\n    }\n  }\n};",{"version":3,"sources":["Home.vue"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA4BA;AACA,OAAA,KAAA,MAAA,wBAAA;AACA,OAAA,OAAA,MAAA,0BAAA,C,CAEA;AACA;;AACA,OAAA,KAAA,MAAA,OAAA;AACA,OAAA,CAAA,MAAA,QAAA;AAEA,eAAA;AACA,QAAA,MADA;AAEA,cAAA;AACA,gBADA;AAEA;AAFA,GAFA;AAMA,QAAA,gBAAA;AACA,WAAA;AACA,eAAA,WADA;AACA;AACA,mBAAA,EAFA;AAEA;AACA,iBAAA,IAHA,CAGA;;AAHA,KAAA;AAKA,GAZA;AAaA,WAAA;AACA,kBADA,0BACA,KADA,EACA;AACA,WAAA,OAAA,GAAA,KAAA,CADA,CACA;;AACA,WAAA,MAAA,GAFA,CAEA;AAEA,KALA;AAMA,UANA,oBAMA;AAAA;;AACA;AACA,YAAA,sDAAA,KAAA,OAAA,EAAA;AACA,gBAAA,KADA;AAEA;AACA;AACA;AACA,cAAA,SALA;AAMA,iBAAA;AACA,yCAAA,GADA;AAEA,0BAAA;AAFA;AANA,OAAA,EAWA;AAXA,OAYA,IAZA,CAYA,UAAA,QAAA,EAAA;AACA;AACA,cAAA,WAAA,CAAA,MAAA,GAAA,CAAA,CAFA,CAIA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,YAAA,OAAA,CAAA;AAAA,YAAA,KAAA,CAAA,CAlBA,CAoBA;;AACA,aAAA,IAAA,MAAA,CAAA,EAAA,MAAA,SAAA,IAAA,CAAA,QAAA,CAAA,MAAA,EAAA,KAAA,EAAA;AAEA;AACA,cAAA,QAAA,IAAA,EAAA;AACA;AACA;AACA,gBAAA,MAAA;AACA,kBAAA,EADA;AAEA,oBAAA,SAAA,IAAA,CAAA,IAFA;AAGA,mBAAA,SAAA,IAAA,CAAA,QAAA,CAAA,IAAA,EAAA,MAAA,CAAA,KAAA,CAAA,GAAA,EAAA,CAAA,CAHA;AAIA,oBAAA,SAAA,IAAA,CAAA,QAAA,CAAA,IAAA,EAAA,IAAA,CAAA,IAJA;AAKA,wBAAA,SAAA,IAAA,CAAA,QAAA,CAAA,IAAA,EAAA,IAAA,CAAA,QALA;AAMA,yBAAA,SAAA,IAAA,CAAA,QAAA,CAAA,IAAA,EAAA,IAAA,CAAA,KANA,CAQA;;AARA,aAAA;;AASA,kBAAA,WAAA,CAAA,IAAA,CAAA,GAAA,EAZA,CAaA;;;AACA,oBAAA,CAAA,CAdA,CAeA;AACA;;AACA;AACA;AACA,SA3CA,CA4CA;AACA;;;AACA,cAAA,SAAA,GAAA,IAAA;AACA,OA3DA,EA4DA;AA5DA,OA6DA,KA7DA,CA6DA,UAAA,KAAA,EAAA;AACA;AACA,YAAA,MAAA,QAAA,CAAA,MAAA,IAAA,GAAA,EAAA;AACA,gBAAA,SAAA,GAAA,mFAAA;AACA;AACA,OAlEA;AAmEA;AA3EA;AAbA,CAAA","sourcesContent":["/**\nApp     : Forecaster\nFile    : views/Home.vue\nPurpose : Get data from backend and render into components\nVersion : 1.0\nAuthor  : Liselot Ramirez\nDate    : 17.08.2018\n**/\n<template>\n  <div class=\"home\">\n    <!-- If someone wrote the city/zip code and clicked on search, the value is passed\n        to this parent via the @clicked attribute. -->\n    <Query @clicked=\"onSearchSubmit\" />\n\n    <!-- If your city/zip code was wrong and you found an error, show it! -->\n    <div v-show=\"ajaxerror != null\" class=\"ajaxerror\">\n      {{ajaxerror}}\n    </div>\n\n    <!-- If we have all the data and there's no error, then render the results -->\n    <div v-if=\"allForecast.length > 0 && ajaxerror == null\">\n        <!-- :weather is the array with all the results objects -->\n        <Results :weather=\"allForecast\" />\n    </div>\n  </div>\n</template>\n\n<script>\n// @ is an alias to /src\nimport Query from \"@/components/Query.vue\";\nimport Results from \"@/components/Results.vue\";\n\n// Import axios for the ajax call (works with Vuejs)\n// Import lodash to loop in the response and pass it to the result array\nimport axios from 'axios';\nimport _ from 'lodash';\n\nexport default {\n  name: \"home\",\n  components: {\n    Query,\n    Results\n  },\n  data: () => {\n        return {\n          reqCity: \"your city\",//request city (from search query component)\n          allForecast: [],//all the result objects from the server's response \n          ajaxerror: null //in case there's an error in the ajax call, but don't fill this out yet\n        }\n  },\n  methods: {\n    onSearchSubmit (value) {\n      this.reqCity = value; //the value we receive from the Query component via @clicked, to the reqCity variable\n      this.getObj(); //After we get the value, then we can make the ajax call\n      \n    },\n     getObj() {\n       //url from the localhost; grabs forecast from the custom made ASP.Net Core API\n      axios(\"https://localhost:5001/api/weather/forecast?city=\" + this.reqCity,{\n        method: 'GET',\n        // THE FOLLOWING IS TO ALLOW THE LOCALHOST TO ACCESS THE BACKEND\n        // I know this is a bad practice, but this is just for the localhost.\n        // On production this will change, to reinforce credentials\n        mode: 'no-cors',\n        headers: {\n            'Access-Control-Allow-Origin': '*',\n            'Content-Type': 'application/json',\n          }\n      })\n      // IF THE PROMISE SUCCEEDS...\n      .then((response)  =>  {\n        //We reset the allForecast variable, to clean it from previous value, enabling re-use\n        this.allForecast.length = 0;\n        \n        //Let's find what we want: today's weather and forecast for the next 5 days\n        //First, let's find the weather, and also assign an id. The response.data.forecast\n        //comes with 40 items, starting with the weather for today at the last reading (from the \n        //OpenWeatherApp) until the equivalent last hour reading five days from now.\n        //How can we find the five days forecast? Let's check it out:\n\n        //VARS:\n        // -----------------------------------------------------------------------------------\n        // find: Keeps track of the index on the response.data.forecast. The data is read\n        //       every three hours, so every 8 readings is the data of this same time period,\n        //       but on the following days.\n        // id:   We need to keep track of an id for today and the next days. This id will be\n        //       passed on the result object we're collecting.\n        // -----------------------------------------------------------------------------------\n        var find = 0, id = 0;\n\n        //Let's loop this baby\n        for(var key = 0; key < response.data.forecast.length; key++){\n          \n          //Hey! If the key matches the find, then we got an object for the day!\n          if(key === find){\n            //Our object will contain id, city, day (as in date mm/dd), temperature, humidity, and wind speed\n            //^^ (based on specs) \n            var obj = {\n              id: id,\n              city: response.data.city,\n              day: response.data.forecast[find].dt_txt.split(\" \")[0],\n              temp: response.data.forecast[find].main.temp,\n              humidity: response.data.forecast[find].main.humidity,\n              windspeed: response.data.forecast[find].wind.speed            \n            }\n            //Once we capture our object, we push it to the allForecast array :)\n            this.allForecast.push(obj);\n            //Now find will be find + 7, i.e. second match will be key === 7 and find === 7\n            find += 7;\n            //Remember to update the id! Otherwise the objects will have the same id and that's\n            //not good for our children components! (Do it for the children bro)\n            id++;\n          }\n        }\n        //After all the wilderness has passed, also put the ajaxerror as null here.\n        //This avoids to have the ajaxerror displaying when the new query is successful.\n        this.ajaxerror = null;\n      })\n      //IF THE PROMISE IS UNSUCCESSFUL...\n      .catch((error) => {\n        // Error! you found it? You post it!\n        if(error.response.status == 400){\n            this.ajaxerror = \"That zip code or city is not in Germany, or is made up. Please review your input.\";\n        }\n    });\n    }\n  }\n};\n</script>\n"],"sourceRoot":"src/views"}]}